// Package models provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.3 DO NOT EDIT.
package models

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for ApplicationDeploymentProfileType.
const (
	HelmV3 ApplicationDeploymentProfileType = "helm.v3"
)

// Defines values for ApplicationPackageSpecSourceType.
const (
	GITREPO ApplicationPackageSpecSourceType = "GIT_REPO"
)

// Defines values for ApplicationPackageStatusState.
const (
	DELETED        ApplicationPackageStatusState = "DELETED"
	DELETEPENDING  ApplicationPackageStatusState = "DELETE_PENDING"
	ONBOARDED      ApplicationPackageStatusState = "ONBOARDED"
	ONBOARDPENDING ApplicationPackageStatusState = "ONBOARD_PENDING"
	STAGED         ApplicationPackageStatusState = "STAGED"
	STAGEPENDING   ApplicationPackageStatusState = "STAGE_PENDING"
)

// APIResponse defines model for APIResponse.
type APIResponse struct {
	RequestId string    `json:"requestId"`
	Timestamp time.Time `json:"timestamp"`
}

// AppPackageStatus defines model for AppPackageStatus.
type AppPackageStatus struct {
	LastUpdateTime *time.Time `json:"lastUpdateTime,omitempty"`
	Message        *string    `json:"message,omitempty"`
	Phase          *string    `json:"phase,omitempty"`
}

// ApplicationDeployment defines model for ApplicationDeployment.
type ApplicationDeployment struct {
	ApiVersion string   `json:"apiVersion"`
	Kind       string   `json:"kind"`
	Metadata   Metadata `json:"metadata"`
	Spec       struct {
		AppPackageRef *struct {
			Id *string `json:"id,omitempty"`
		} `json:"appPackageRef,omitempty"`
		DeploymentProfile *ApplicationDeploymentProfile `json:"deploymentProfile,omitempty"`
		Parameters        *ApplicationParameters        `json:"parameters,omitempty"`
	} `json:"spec"`
	Status *AppPackageStatus `json:"status,omitempty"`
}

// ApplicationDeploymentList defines model for ApplicationDeploymentList.
type ApplicationDeploymentList struct {
	ApiVersion string                  `json:"apiVersion"`
	Items      []ApplicationDeployment `json:"items"`
	Kind       string                  `json:"kind"`
	Metadata   *struct {
		Continue           *string `json:"continue,omitempty"`
		RemainingItemCount *int    `json:"remainingItemCount,omitempty"`
	} `json:"metadata,omitempty"`
}

// ApplicationDeploymentProfile defines model for ApplicationDeploymentProfile.
type ApplicationDeploymentProfile struct {
	Components *[]ApplicationDeploymentProfileComponent `json:"components,omitempty"`
	Type       *ApplicationDeploymentProfileType        `json:"type,omitempty"`
}

// ApplicationDeploymentProfileType defines model for ApplicationDeploymentProfile.Type.
type ApplicationDeploymentProfileType string

// ApplicationDeploymentProfileComponent defines model for ApplicationDeploymentProfileComponent.
type ApplicationDeploymentProfileComponent struct {
	Name       *string `json:"name,omitempty"`
	Properties *struct {
		Repository *string `json:"repository,omitempty"`
		Revision   *string `json:"revision,omitempty"`
		Timeout    *string `json:"timeout,omitempty"`
		Wait       *bool   `json:"wait,omitempty"`
	} `json:"properties,omitempty"`
}

// ApplicationPackage defines model for ApplicationPackage.
type ApplicationPackage struct {
	ApiVersion string   `json:"apiVersion"`
	Kind       string   `json:"kind"`
	Metadata   Metadata `json:"metadata"`
	Spec       struct {
		// Source Source configuration based on sourceType
		Source *ApplicationPackage_Spec_Source `json:"source,omitempty"`

		// SourceType Type of source for the application package
		SourceType *ApplicationPackageSpecSourceType `json:"sourceType,omitempty"`
	} `json:"spec"`
	Status *ApplicationPackageStatus `json:"status,omitempty"`
}

// ApplicationPackage_Spec_Source Source configuration based on sourceType
type ApplicationPackage_Spec_Source struct {
	union json.RawMessage
}

// ApplicationPackageSpecSourceType Type of source for the application package
type ApplicationPackageSpecSourceType string

// ApplicationPackageList defines model for ApplicationPackageList.
type ApplicationPackageList struct {
	ApiVersion string               `json:"apiVersion"`
	Items      []ApplicationPackage `json:"items"`
	Kind       string               `json:"kind"`
	Metadata   *struct {
		Continue           *string `json:"continue,omitempty"`
		RemainingItemCount *int    `json:"remainingItemCount,omitempty"`
	} `json:"metadata,omitempty"`
}

// ApplicationPackageStatus defines model for ApplicationPackageStatus.
type ApplicationPackageStatus struct {
	ContextualInfo *struct {
		Code    *string `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	} `json:"contextualInfo,omitempty"`
	LastUpdateTime *time.Time                     `json:"lastUpdateTime,omitempty"`
	State          *ApplicationPackageStatusState `json:"state,omitempty"`
}

// ApplicationPackageStatusState defines model for ApplicationPackageStatus.State.
type ApplicationPackageStatusState string

// ApplicationParameterTarget defines model for ApplicationParameterTarget.
type ApplicationParameterTarget struct {
	Components *[]string `json:"components,omitempty"`
	Pointer    *string   `json:"pointer,omitempty"`
}

// ApplicationParameterValue defines model for ApplicationParameterValue.
type ApplicationParameterValue struct {
	Targets *[]ApplicationParameterTarget `json:"targets,omitempty"`
	Value   *string                       `json:"value,omitempty"`
}

// ApplicationParameters defines model for ApplicationParameters.
type ApplicationParameters map[string]ApplicationParameterValue

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Details   *map[string]interface{} `json:"details,omitempty"`
	ErrorCode string                  `json:"errorCode"`
	RequestId string                  `json:"requestId"`
	Timestamp time.Time               `json:"timestamp"`
}

// GitRepo Git repository source configuration
type GitRepo struct {
	// AccessToken Git access token for authentication
	AccessToken *string `json:"accessToken,omitempty"`

	// Branch Git branch to use
	Branch *string `json:"branch,omitempty"`

	// SubPath Subdirectory within the repository containing the application description yaml (ex margo.yaml)
	SubPath *string `json:"subPath,omitempty"`

	// Tag Git tag to use (alternative to branch)
	Tag *string `json:"tag,omitempty"`

	// Url Git repository URL (only HTTPS is supported)
	Url string `json:"url"`

	// Username Git username for authentication
	Username *string `json:"username,omitempty"`
	union    json.RawMessage
}

// GitRepo0 defines model for .
type GitRepo0 = interface{}

// GitRepo1 defines model for .
type GitRepo1 = interface{}

// Metadata defines model for Metadata.
type Metadata struct {
	Annotations       *map[string]string `json:"annotations,omitempty"`
	CreationTimestamp *time.Time         `json:"creationTimestamp,omitempty"`
	Labels            *map[string]string `json:"labels,omitempty"`
	Name              string             `json:"name"`
	Namespace         *string            `json:"namespace,omitempty"`
}

// ValidationError defines model for ValidationError.
type ValidationError struct {
	Field   string `json:"field"`
	Message string `json:"message"`
}

// ListApplicationDeploymentsParams defines parameters for ListApplicationDeployments.
type ListApplicationDeploymentsParams struct {
	Limit    *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Continue *string `form:"continue,omitempty" json:"continue,omitempty"`
}

// ListAppPackagesParams defines parameters for ListAppPackages.
type ListAppPackagesParams struct {
	Limit    *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Continue *string `form:"continue,omitempty" json:"continue,omitempty"`
}

// DeleteAppPackageParams defines parameters for DeleteAppPackage.
type DeleteAppPackageParams struct {
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// CreateApplicationDeploymentJSONRequestBody defines body for CreateApplicationDeployment for application/json ContentType.
type CreateApplicationDeploymentJSONRequestBody = ApplicationDeployment

// OnboardAppPackageJSONRequestBody defines body for OnboardAppPackage for application/json ContentType.
type OnboardAppPackageJSONRequestBody = ApplicationPackage

// AsGitRepo returns the union data inside the ApplicationPackage_Spec_Source as a GitRepo
func (t ApplicationPackage_Spec_Source) AsGitRepo() (GitRepo, error) {
	var body GitRepo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGitRepo overwrites any union data inside the ApplicationPackage_Spec_Source as the provided GitRepo
func (t *ApplicationPackage_Spec_Source) FromGitRepo(v GitRepo) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGitRepo performs a merge with any union data inside the ApplicationPackage_Spec_Source, using the provided GitRepo
func (t *ApplicationPackage_Spec_Source) MergeGitRepo(v GitRepo) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t ApplicationPackage_Spec_Source) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ApplicationPackage_Spec_Source) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGitRepo0 returns the union data inside the GitRepo as a GitRepo0
func (t GitRepo) AsGitRepo0() (GitRepo0, error) {
	var body GitRepo0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGitRepo0 overwrites any union data inside the GitRepo as the provided GitRepo0
func (t *GitRepo) FromGitRepo0(v GitRepo0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGitRepo0 performs a merge with any union data inside the GitRepo, using the provided GitRepo0
func (t *GitRepo) MergeGitRepo0(v GitRepo0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsGitRepo1 returns the union data inside the GitRepo as a GitRepo1
func (t GitRepo) AsGitRepo1() (GitRepo1, error) {
	var body GitRepo1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGitRepo1 overwrites any union data inside the GitRepo as the provided GitRepo1
func (t *GitRepo) FromGitRepo1(v GitRepo1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGitRepo1 performs a merge with any union data inside the GitRepo, using the provided GitRepo1
func (t *GitRepo) MergeGitRepo1(v GitRepo1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t GitRepo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.AccessToken != nil {
		object["accessToken"], err = json.Marshal(t.AccessToken)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'accessToken': %w", err)
		}
	}

	if t.Branch != nil {
		object["branch"], err = json.Marshal(t.Branch)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'branch': %w", err)
		}
	}

	if t.SubPath != nil {
		object["subPath"], err = json.Marshal(t.SubPath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subPath': %w", err)
		}
	}

	if t.Tag != nil {
		object["tag"], err = json.Marshal(t.Tag)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tag': %w", err)
		}
	}

	object["url"], err = json.Marshal(t.Url)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'url': %w", err)
	}

	if t.Username != nil {
		object["username"], err = json.Marshal(t.Username)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'username': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *GitRepo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["accessToken"]; found {
		err = json.Unmarshal(raw, &t.AccessToken)
		if err != nil {
			return fmt.Errorf("error reading 'accessToken': %w", err)
		}
	}

	if raw, found := object["branch"]; found {
		err = json.Unmarshal(raw, &t.Branch)
		if err != nil {
			return fmt.Errorf("error reading 'branch': %w", err)
		}
	}

	if raw, found := object["subPath"]; found {
		err = json.Unmarshal(raw, &t.SubPath)
		if err != nil {
			return fmt.Errorf("error reading 'subPath': %w", err)
		}
	}

	if raw, found := object["tag"]; found {
		err = json.Unmarshal(raw, &t.Tag)
		if err != nil {
			return fmt.Errorf("error reading 'tag': %w", err)
		}
	}

	if raw, found := object["url"]; found {
		err = json.Unmarshal(raw, &t.Url)
		if err != nil {
			return fmt.Errorf("error reading 'url': %w", err)
		}
	}

	if raw, found := object["username"]; found {
		err = json.Unmarshal(raw, &t.Username)
		if err != nil {
			return fmt.Errorf("error reading 'username': %w", err)
		}
	}

	return err
}
